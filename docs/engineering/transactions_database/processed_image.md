# ProcessedImage

This article is about the `ProcessedImage` table in the `transactions_db`. In this article, you will learn:
- how the `ProcessedImage` table is structured
- the purpose of the different fields
- the `normal form` of this table

## Fields

This section describes each field and its purpose.

### `id`

This field is the `primary key*- for the table, defined as a universally unique identifier (`UUID`).

#### Constraints:
 - `Primary Key`: Uniquely identifies each processed image record.
 - `Not Nullable`: Every record must have an ID.
 - `Indexed`: Speeds up direct lookups and joins from related tables.

#### Justification:
A `UUID` provides a unique, non-sequential identifier, which is a best practice for security and data management.

### `storage_filename`

This field is a `string` containing the filename of the processed image as it is saved in the backend storage system.

#### Constraints:
 - `Not Nullable`: Every record must correspond to a file in storage.
 - `Max Length`: The filename can be up to 255 characters.

#### Justification:
This provides the direct link to the physical file asset generated by a processing job. This field is not required to be unique, as different processing jobs might produce identically named files.

### `created_at`

This field is a timezone-aware `datetime` that automatically records when the processed image record was created.

#### Constraints:
 - `Not Nullable`: Every record must have a creation timestamp.
 - `Default Value`: The application automatically sets this value to the current time in UTC upon insertion.
#### Justification:
This timestamp is crucial for auditing, displaying results chronologically, and tracking when processing tasks complete.

### `unprocessed_image_id`

This field is a `foreign key*- (`UUID`) that links the processed result back to its original source image.

#### Constraints:
 - `Foreign Key`: It must correspond to a valid `id` in the `UnprocessedImage` table.
 - `Not Nullable`: A processed image must derive from an unprocessed image.
 - `Indexed`: Speeds up queries that find all processed versions of a specific original image.
#### Justification:
This creates the essential relationship between the source and its derivatives, allowing you to trace the lineage of an image. To find the user who owns a processed image, you must join through this field to the `UnprocessedImage` table.

## Table Form Normalization
The `ProcessedImage` table is in `Boyce-Codd Normal Form (BCNF)`.

This design is fully normalized, ensuring data integrity and eliminating redundancy.

### Analysis

Here is a quick analysis of the table and its normal form.

#### First Normal Form (1NF)
The table is in 1NF because it has a primary key (`id`) and all its attributes (`id`, `storage_filename`, etc.) are atomic.

#### Second Normal Form (2NF)
The table is in 2NF because it is in 1NF and has no partial dependencies. Since the primary key (`id`) is a single column, all non-key attributes are fully dependent on it.

#### Third Normal Form (3NF)
The table is in 3NF because it is in 2NF and has no `transitive dependencies`. A transitive dependency would exist if a non-key attribute depended on another non-key attribute.

- In this model, all non-key attributes (`storage_filename`, `created_at`, `unprocessed_image_id`) depend directly and only on the primary key `id`. There are no dependencies between them.

#### Boyce-Codd Normal Form (BCNF)
A table is in BCNF if for every functional dependency, the determinant is a superkey.

- The only candidate key (and therefore superkey) in this table is `id`.
- The only significant functional dependency is `id â†’ (storage_filename, created_at, unprocessed_image_id)`.
- Since the determinant (`id`) is a superkey, the table satisfies BCNF.