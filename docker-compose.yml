# Define the named volumes for persistent storage
volumes:
  transactions_data: # this is a database for storing information about data transactions
  unprocessed_image_data: # use this for staging unprocessed/original files
  processed_image_data: # use this for storing processed/augmented files
# define a reusable block for the common api service settings
x-api-base: &api-base
  build:
    context: .
  # mount data volumes and source code live changes
  volumes:
    # Mount the image storage volume into the container
    # [source_of_data]:[some/file/path]
    - unprocessed_image_data:/image-augmentation-service/data/images/unprocessed
    - processed_image_data:/image-augmentation-service/data/images/processed
  # Pass database credentials to the API service as environment variables
  environment:
    - DATABASE_HOSTNAME=${DATABASE_HOSTNAME}
    - POSTGRES_DB=${POSTGRES_DB}
    - POSTGRES_USER=${POSTGRES_USER}
    - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    - DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${DATABASE_HOSTNAME}:5432/${POSTGRES_DB} # use the variable for a dynamic hostname
  depends_on:
    # tells the api service to wait for the db to start
    - db
  # health check to be run by all api containers
  healthcheck:
    # test specified the actual command to run inside the container
    # runs this curl command directly
    test: ["CMD", "curl", "-f", "http://localhost:8000/healthcheck-api/healthcheck"]
    interval: 5s
    timeout: 10s
    retries: 3
# define the services to be built
services:
  # The FastAPI Application Service
  # the service for testing
  api-dev:
    profiles:
      - dev
    # inherit all settings from our x-api-base block
    <<: *api-base
    # Give the built image a name and tag
    image: image-augmentation-service-api:dev
    # Give the running container a name
    container_name: image-augmentation-api-dev
    build:
      context: .
      target: dev
    ports:
      - "8000:8000"
    volumes:
      - unprocessed_image_data:/image-augmentation-service/data/images/unprocessed
      - processed_image_data:/image-augmentation-service/data/images/processed
      - ./app:/image-augmentation-service/app
      - ./tests:/image-augmentation-service/tests
    command: uv run uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
  # the service for end-to-end tests
  api-end-to-end:
    profiles:
      - end-to-end-test
    # inherit all settings from our x-api-base block
    <<: *api-base
    # Give the built image a name and tag
    image: image-augmentation-service-api:end-to-end
    # Give the running container a name
    container_name: image-augmentation-api-end-to-end
    build:
      context: .
      target: endtoend
    ports:
      - "8000:8000"
    command: uv run uvicorn app.main:app --host 0.0.0.0 --port 8000
    depends_on:
      - db-end-to-end-test # point to the test db
    environment:
      - DATABASE_HOSTNAME=${END_TO_END_TEST_DATABASE_HOSTNAME} # override the hostname of the test db
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${END_TO_END_TEST_DATABASE_HOSTNAME}:5432/${POSTGRES_DB}
  # the service for unit testing
  api-unit-test:
    profiles:
      - unit-test
    # inherit all settings from our x-api-base block
    <<: *api-base
    # Give the built image a name and tag
    image: image-augmentation-service-api:unit-test
    # Give the running container a name
    container_name: image-augmentation-api-unit-test
    build:
      context: .
      target: unittest
    command: uv run pytest tests/unit --cov=. --cov-report=html:tests/coverage_report/web
    depends_on:
      - db-unit-test # point to the test db
    volumes:
      - ./tests/coverage_reports/unit:/image-augmentation-service/tests/coverage_report/web
    environment:
      - PYTHONPATH=/image-augmentation-service
      - DATABASE_HOSTNAME=${UNIT_TEST_DATABASE_HOSTNAME} # override the hostname of the test db
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${UNIT_TEST_DATABASE_HOSTNAME}:5432/${POSTGRES_DB}
  # the service for integration testing
  api-integration-test:
    profiles:
      - integration-test
    # inherit all settings from our x-api-base block
    <<: *api-base
    # Give the built image a name and tag
    image: image-augmentation-service-api:integration-test
    # Give the running container a name
    container_name: image-augmentation-api-integration-test
    build:
      context: .
      target: integrationtest
    command: uv run pytest --cov=. --cov-report=html:tests/coverage_report/web
    depends_on:
      - db-integration-test # point to the test db
    volumes:
      - ./tests/coverage_reports/integration:/image-augmentation-service/tests/coverage_report/web
    environment:
      - PYTHONPATH=/image-augmentation-service
      - DATABASE_HOSTNAME=${INTEGRATION_TEST_DATABASE_HOSTNAME} # override the hostname of the test db
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${INTEGRATION_TEST_DATABASE_HOSTNAME}:5432/${POSTGRES_DB}
  # the service for running end-to-end test scripts
  api-end-to-end-test:
    profiles:
      - end-to-end-test
    # Give the built image a name and tag
    image: image-augmentation-service-api:end-to-end-test
    # Give the running container a name
    container_name: image-augmentation-api-end-to-end-test
    build:
      context: .
      target: endtoendtest
    command: uv run pytest tests/end_to_end
    volumes:
      - ./tests/coverage_reports/end_to_end:/image-augmentation-service/tests/coverage_report/web
    depends_on:
      api-end-to-end:
        condition: service_healthy
    environment:
      - PYTHONPATH=/image-augmentation-service
      - API_BASE_URL=http://api-end-to-end:8000
  # the service for production
  api-prod:
    profiles:
      - prod
    # inherit all settings from our x-api-base block
    <<: *api-base
    # Give the built image a name and tag
    image: image-augmentation-service-api:latest
    # Give the running container a name
    container_name: image-augmentation-api-prod
    build:
      context: .
      target: prod
    ports:
      - "8000:8000"
    # override the volume to remove the source code mounts
    volumes:
      - unprocessed_image_data:/image-augmentation-service/data/images/unprocessed
      - processed_image_data:/image-augmentation-service/data/images/processed
  # the PostgreSQL database service is shared by all environments
  db:
    # The PostgreSQL Database Service to store transaction information
    image: postgres:16-alpine # Use the official PostgreSQL image
    volumes:
      # Mount the volume to persist the data
      - transactions_data:/var/lib/postgresql/data
    environment:
      # use the variables from the .env file
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    restart: always
    container_name: image-augmentation-transactions-db
    profiles:
      - dev
      - prod
  db-unit-test:
    # the testing PostgreSQL Database Service to store transaction information
    image: postgres:16-alpine # use the official PostgreSQL image
    tmpfs:
      - /var/lib/postgresql/data # make this database ephemeral (store in RAM)
    environment:
      # use the variables from the .env file
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    container_name: image-augmentation-transactions-db-unit-test
    profiles:
      - unit-test
  db-integration-test:
    # the testing PostgreSQL Database Service to store transaction information
    image: postgres:16-alpine # use the official PostgreSQL image
    tmpfs:
      - /var/lib/postgresql/data # make this database ephemeral (store in RAM)
    environment:
      # use the variables from the .env file
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    container_name: image-augmentation-transactions-db-integration-test
    profiles:
      - integration-test
  db-end-to-end-test:
    # the testing PostgreSQL Database Service to store transaction information
    image: postgres:16-alpine # use the official PostgreSQL image
    tmpfs:
      - /var/lib/postgresql/data # make this database ephemeral (store in RAM)
    environment:
      # use the variables from the .env file
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    container_name: image-augmentation-transactions-db-end-to-end-test
    profiles:
      - end-to-end-test